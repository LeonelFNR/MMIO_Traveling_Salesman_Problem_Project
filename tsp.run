reset;
model tsp.mod;
data tsp.dat;
option solver cplex;

# Inicializamos el conjunto de cortes como vac√≠o antes de nada
let CUTS := {};

# =========================================================
# SECTION (a): HEURISTIC UPPER BOUND (Constructive + 2-Opt)
# =========================================================
print "=== SECTION (a) Part 1: Heuristic ===";

# 1. Nearest Neighbor
let tour[1] := 1;
let visited[1] := 1;
let current_node := 1;
for {step in 2..n} {
    let min_dist := Infinity;
    let next_node := 0;
    for {j in NODES} {
        if visited[j] = 0 and dist[current_node, j] < min_dist then {
            let min_dist := dist[current_node, j];
            let next_node := j;
        }
    }
    let tour[step] := next_node;
    let visited[next_node] := 1;
    let current_node := next_node;
}
let tour[n+1] := 1;
let best_cost := sum {k in 1..n} dist[tour[k], tour[k+1]];

# 2. 2-Opt Improvement
let improved := 1;
repeat while improved > 0 {
    let improved := 0;
    for {i in 1..n-2} {
        for {j in i+2..n} {
             if dist[tour[i], tour[j]] + dist[tour[i+1], tour[j+1]] < 
                dist[tour[i], tour[i+1]] + dist[tour[j], tour[j+1]] then {
                for {k in 0..floor((j - (i+1))/2)} {
                    let tmp := tour[i+1+k];
                    let tour[i+1+k] := tour[j-k];
                    let tour[j-k] := tmp;
                }
                let improved := 1;
                break; 
            }
        }
        if improved = 1 then break;
    }
}
let best_cost := sum {k in 1..n} dist[tour[k], tour[k+1]];
printf "Heuristic Upper Bound: %g\n", best_cost;


# =========================================================
# SECTION (a) Part 2: INITIAL RELAXATION (Lower Bound)
# =========================================================
print "\n=== SECTION (a) Part 2: Linear Relaxation ===";
option relax_integrality 1; # Allow fractional values

solve;
display Total_Cost;

# =========================================================
# SECTION (b): AUTOMATIC SUBTOUR ELIMINATION
# =========================================================
print "\n=== SECTION (b): Automatic Separation Algorithm ===";

param num_cuts default 0;
param iter default 0;
param n_nodes default card(NODES);
set UNVISITED;
set CURRENT_COMPONENT;
param found_subtour;
param node_added;

# Repeat max 3 times as per instructions
repeat {
    let iter := iter + 1;
    printf "\n--- Iteration %d ---\n", iter;
    
    solve; # Solve with current cuts
    display Total_Cost;
    
    # Flood-fill algorithm to find connected components
    let UNVISITED := NODES;
    let found_subtour := 0;
    
    repeat while card(UNVISITED) > 0 {
        # --- CORRECCION AQUI ---
        # Usamos 'min' para coger un nodo cualquiera sin error de orden
        let CURRENT_COMPONENT := {min {k in UNVISITED} k};
        
        # Expand component
        repeat {
            let node_added := 0;
            for {i in CURRENT_COMPONENT} {
                for {j in UNVISITED diff CURRENT_COMPONENT} {
                    # Check if edge exists (check both i,j and j,i)
                    if (if i < j then x[i,j] else x[j,i]) > 0.001 then {
                        let CURRENT_COMPONENT := CURRENT_COMPONENT union {j};
                        let node_added := 1;
                    }
                }
            }
        } until node_added = 0;
        
        let UNVISITED := UNVISITED diff CURRENT_COMPONENT;
        
        # If component size < total nodes -> It's a Subtour!
        if card(CURRENT_COMPONENT) < n_nodes then {
            let found_subtour := 1;
            let num_cuts := num_cuts + 1;
            
            printf " > Found Subtour %d (Size: %d)\n", num_cuts, card(CURRENT_COMPONENT);
            
            # Add to model dynamic sets
            let CUTS := CUTS union {num_cuts};
            let SUBTOUR_NODES[num_cuts] := CURRENT_COMPONENT;
            
            break; # Re-solve immediately (Greedy strategy)
        }
    }
    
    if found_subtour = 0 then {
        print " > No subtours found. Graph is connected.";
        break;
    }
    
} until iter >= 3;

print "Active edges after (b):";
for {i in NODES, j in NODES: i < j} {
    if x[i,j] > 0.001 then printf "(%d, %d) = %.2f\n", i, j, x[i,j];
}


# =========================================================
# SECTION (c): VALID INEQUALITY (Manual)
# =========================================================
print "\n=== SECTION (c): Valid Inequality (Manual) ===";
# Look for fractional cycles (e.g. 0.5s) in the output above.
# UNCOMMENT ONE EXAMPLE BELOW and ADJUST node IDs:

# Example: If triangle 1-2-3 is fractional (0.5 each):
# subject to Valid_Ineq: x[1,2] + x[2,3] + x[1,3] <= 2;

solve;
display Total_Cost;

print "Active edges after (c):";
for {i in NODES, j in NODES: i < j} {
    if x[i,j] > 0.001 then printf "(%d, %d) = %.2f\n", i, j, x[i,j];
}

# =========================================================
# SECTION (d): GOMORY CUT (Manual)
# =========================================================
print "\n=== SECTION (d): Gomory Cut (Manual) 1st time ===";

subject to Gomory_Cut_1: x[1,2] + x[1,4] + x[2,4] <= 1;

solve;
display Total_Cost;

print "Active edges after (d) first time:";
for {i in NODES, j in NODES: i < j} {
    if x[i,j] > 0.001 then printf "(%d, %d) = %.2f\n", i, j, x[i,j];
}

print "\n=== SECTION (d): Gomory Cut (Manual) 2nd time ===";
subject to Gomory_Cut_2: x[6,7] + x[6,11] + x[7,11] <= 1;

solve;
display Total_Cost;

print "Active edges after (d) second time:";
for {i in NODES, j in NODES: i < j} {
    if x[i,j] > 0.001 then printf "(%d, %d) = %.2f\n", i, j, x[i,j];
}


# =========================================================
# SECTION (e): BRANCH AND BOUND
# =========================================================
print "\n=== SECTION (e): Branch & Bound ===";
option relax_integrality 0; # Back to binary

solve;
display Total_Cost;

print "Optimal Tour:";
for {i in NODES, j in NODES: i < j} {
    if x[i,j] > 0.9 then printf "(%d, %d) ", i, j;
}
print "";